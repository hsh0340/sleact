## Section 0
### NestJS 강좌 시작!
- NestJS 특징
  - 초반 세팅 복잡하다.
  - Express 처럼 직관적이지는 않다.
  - Typescript이고, swagger 자동으로 만들어준다.
  - 많은 기능들을 제공하는데 다 필요한 기능들이다.
  - Express 위에서 만들어졌기 때문에 middleware 재사용 할 수 있다.
  - 각각의 코드가 어떤 역할을 하는지가 명확하다. 하나의 개념이 한 가지 역할을 수행한다.
  - module간의 의존성이 명확해서 서버의 구조를 파악하기가 좋다.
  - 객체지향 개념(DI, AOP 등)을 익히면서 프로그래밍에 대한 시야가 넓어진다.
- 공식문서를 n회독 할 것. 궁금한 것의 90%는 공식문서에 나와있다.


### Express와의 비교
- NestJS는 express를 내부적으로 사용하고 있다. 그래서 Express에 대해 기본적으로 알고 있는 것이 좋다.
- 남의 프로젝트를 인수인계 받았으면 package.json을 보면서 무슨 패키지를 사용했는지 보는 것이 좋다.
- Express는 구조가 자유로운 대신 사람마다 구조가 다 제각각일 수 있다.
- NestJS는 요청과 응답을 몰라도 실행될 수 있도록 더 나은 설계로 바뀌었다.

### NestJS 세팅하기
- @nestjs/cli 설치하는 것이 시작이다.
``` bash
$ npm i -g @nestjs/cli
```
프로젝트 시작하려는 위치의 부모 폴더에 들어가서 명령어 실행한다.

#### main.ts
- Nest 서비스가 시작되는 곳.
- bootstrap() 함수를 실행한다.

### 핫 리로딩 설정
- NestJS도 기본적으로 node.js 기반 이므로 소스코드가 수정되면 서버를 재시작 해야한다. Express에서 nodemon을 사용한 것 처럼 NestJS도 hot reload 설정을 해줄 수 있다. 
- 공식문서에 나와있는 세팅을 적용한다.

### controller 기본
- NestJS는 모듈 시스템으로 구성되어있다. Express에서는 라우터 위주의 설계라면, NestJS는 모듈 위주의 설계이다.
- controller === router 매칭된다.
- 데코레이터를 붙여놓으면 NestJS가 알아서 해준다. 개발자들이 이거 어떻게 돌아가는거지? 라는 거부감을 가질 수 있다.(제어의 역전, IoC) -> 마법같은 Nest✨
- 다만 module을 직접 구성해야한다는 점에서 스프링보다 IoC가 약하다.
- 만들어준 controller는 module 파일에서 추가해줘야한다. 추가 안했는데 사용하려고 하면 로그가 뜨니, 실수로 빼먹었다면 고쳐주자.

### 서비스를 분리하는 이유, 컨트롤러의 장점
- 컨트롤러에서 다 처리해서 리턴하면 되지 왜 굳이 한 뎁스가 더 있을까?
  - 서비스의 역할: 비즈니스 로직의 분리(비즈니스 로직 = 실제 동작)
  - 실제 라우터가 해야하는 동작은 서비스에 넣고, 컨트롤러는 서비스를 실행하고 결과 값만 받아서 리턴한다.
- 그래서 분리하는 이유? 
  - 컨트롤러는 req와 res에 대해 알아야한다.
  - 서비스단위에서는 req와 res에 대해서는 몰라야한다(딱 메서드 그 자체만). input을 원하는 데이터로 자유자재로 넣어보고, output도 자유자재로 나와야 한다. 그래야 메서드를 재사용 하기도 좋고, 테스트 하기도 좋다..
  - req, res 쓰는게 안좋은 이유? 
    - 테스트 할 때 꼭 req,res 를 mocking 해줘야 하기 때문에. 아무 데이터 집어넣고 갖고 놀 수 있어야 한다.
- 편리한 기능들을 미들웨어를 일일히 구성해서 처리하는 것이 아니라 NestJS의 공식적인 기능(인터셉터 등)으로 처리한다.


### ConfigModule 사용하기
```bash
$ npm i --save @nestjs/config
```
- 그냥 dotenv 모듈 써도 되지 않나? 
  - Nest는 모듈 시스템이다. dotenv를 갖다 쓰려고 해도 dotenv를 Nest의 모듈로 만들어서 써야한다. nestjs/config는 이미 모듈로 감싸놨기 때문에 감싸진거 쓰면 된다.
- .env를 배포환경, 개발환경에 따라 다른 파일로 관리하여 사용할 수 있다.
- process.env를 직접 쓰기 보다는 configService를 사용하는 것이 좋다. .
  - env 환경변수 자체는 NestJS와 관련이 없으므로 완전히 NestJS애게 모듈화 한 채로 맡기는 것이 좋다. 그래야 의존성 주입할 때 자유자재로 관리할 수 있다.

### loggerMiddleware로 morgan처럼 로깅하기
- NestMiddleware interface를 상속 받아 구현한다.
- use() 함수의 파라미터로 request, response, next가 있다. Express 미들웨어와 동일하다.
- NestJS에서는 console.log가 아닌 Logger 객체를 쓰는 것이 좋다. 
  - 여러 곳에서 log를 찍으면 어떤 실행과정에서 찍힌 log인지 구별하기 힘들다. Logger의 context 지정해두면 context 끼리 찍히는 로그가 달라진다. HTTP context 이면 [HTTP] 이런식으로 로그가 찍힌다.
- 구현 하고 나서 모듈에 적용할 때는 NestModule을 상속받는다. consumer에 middleware를 연결한다.
- 라우터보다 먼저 실행되어서 (1)request에 대한 기록을 하고, (2)next()로 라우터의 내용을 실행하고, (3)라우터 끝나고 나서 reponse를 가지고 기록을 한다. 

### implements, injectable(DI) 알아보기
- implements를 쓰면 무조건 구현을 해야한다. 어차피 내가 통으로 구현할 것을 이미 만들어진 interface를 상속하여 구현하면 강제성이 생기기 때문에 정확하게 구현할 수 있다.
- @Injectable() 붙어있는 것을 ```provider``` 라고 한다. provider를 사용하려는 모듈 단위에서 provider:[] 안에 적어서 이것을 주입 받을것이라고 알려줘야한다.
- NestJS는 DI라는 개념이 있기 때문에, NestJS가 provider에 연결되어있는지를 보고 연결해준다. 
  - DI를 해주면 내가 직접 new를 사용하지 않고 생성자에서 의존성을 주입한다. 이는 Nest에게 권리를 위임하는 것이다.
  - new로 인스턴스를 만들어서 갖다 박아버리면 결합성이 강해지기 때문에(갈아 끼우기가 불편), 생성자가 바뀔 때마다 코드를 수정해야한다. 실제 구현 대상을 '주입'만 해준다면, 추상과 구현이 분리되기 때문에 코드가 유연해지고, 테스트 하기도 쉽다.
    - provider 설정 부분에서 provide(고유한 키)와 useClass(실제로 사용할, 갈아 끼우는 클래스)로 나누어져 있는 것이 원형이다.
- 마법이 일어나는 것을 즐기려면 원리를 알자~